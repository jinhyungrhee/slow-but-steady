# 정렬(Sort)

## 선택 정렬(Selection Sort)

- 가장 원시적인 방법으로 매번 '가장 작은 것을 선택'하여 정렬하는 알고리즘
- 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복 (이미 정렬된 데이터는 이후 정렬과정에서 제외함)
- 가장 작은 데이터를 앞으로 보내는 과정을 'n-1'번 반복
- 시간복잡도 : n + (n-1) + (n-2) + ... + 2 = n(n+1)/2 = `O(n^2)`

## 삽입 정렬(Insertion Sort)

- 특정한 데이터를 적절한 위치에 '삽입'하여 정렬하는 알고리즘
- 선택 정렬에 비해 실행 시간 측면에서 더 효율적인 정렬 알고리즘
  - 필요시에만 위치를 바꾸므로 '데이터가 거의 정렬되어 있을 때' 매우 효율적
- 삽입 정렬은 두 번째 데이터부터 시작함
  - 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문
- 시간복잡도 : (w.c) `O(n^2)`, (b.c) `O(n)`

## 퀵 정렬(Quick Sort)

- 기준(=피벗)을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작
- 시간복잡도 : (w.c) `O(n^2)`, (b.c) `O(nlogn)`
  - 리스트의 가장 왼쪽 데이터를 피벗으로 삼을 때, '이미 데이터가 정렬되어 있는 경우' 매우 느리게 동작

## 계수 정렬

- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
  - 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리
  - 조건만 만족한다면 데이터의 개수가 많을 때에도 효과적
- '데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때'만 사용 가능
  - 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 백만(1,000,000)을 넘지 않을 때 효과적
  - '모든 범위를 담을 수 있는 크기의 리스트(배열)'를 선언해야 함
- 계수 정렬은 비교 기반의 정렬 알고리즘은 아님!
- 시간복잡도 : `O(n + k)` (n:데이터의 개수, k:데이터 중 최대값의 크기)

## 파이썬 정렬 라이브러리

- sorted()
  ```py
  array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

  result = sorted(array)
  print(result)
  ```
  - 집합(set) 자료형이나 딕셔너리(dict) 자료형을 입력받아도 '리스트'를 결과로 반환!

- sort()
  ```py
  array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

  array.sort()
  print(array)
  ```
  - 리스트 객체의 내장 함수. 별도의 정렬된 리스트가 반환되지 않고 내부 원소가 바로 정렬됨

- key 매개변수를 사용한 예시
  ```py
  array = [('바나나', 2), ('사과', 5), ('당근', 3)]

  def setting(data):
      return data[1]

  result = sorted(array, key=setting)

  # lambda : 첫 번째 원소로 '오름차순' 정렬
  '''
  result = sorted(array, key=lambda x:x[1])
  result = sorted(array, key=lambda x:x[1])
  array.sort(key=lambda x:x[1])
  '''

  # lambda : 두 번째 원소로 '내림차순' 정렬
  '''
  result = sorted(array, key=lambda x:-x[1])
  result = sorted(array, key=lambda x:x[1], reverse=True)
  array.sort(key=lambda x:-x[1])
  '''
  print(result)
  ```
  - key 값으로는 함수가 들어감. lambda함수 사용 가능.

## 정렬 문제 3가지 유형

1. 정렬 라이브러리로 풀 수 있는 문제
2. 정렬 알고리즘의 원리에 대해서 물어보는 문제 - 선택정렬, 삽입정렬, 퀵정렬 등
3. 더 빠른 정렬이 필요한 문제 - 계수 정렬 이용 or 알고리즘의 구조적인 개선