# 비트와 부분 집합

## 비트 연산자

|연산자|의미|사용법|예제|설명|
|:--:|:--:|:--:|--:|:--:|
|&|AND|x & y|</t>x = 00000011(2) = 3 </br> y = 00000110(2) = 6 </br> x & y → 00000010(2) = 2|두 비트가 모두 1일 경우에만 1|
|\||OR|x \| y|x = 00000011(2) = 3 </br> y = 00000110(2) = 6 </br> x \| y → 00000111(2) = 7|두 비트 중에서 하나라도 1이면 1|
|^|XOR|x ^ y|x = 00000011(2) = 3 </br> y = 00000110(2) = 6 </br> x ^ y → 00000101(2) = 5 </br> (x ^ y) ^ y → 00000011(2) = 3|두 비트가 같으면 0, 다르면 1|
|~|NOT|~x|x = 00000010(2) = 2 </br> ~x = 11111101(2) = 253|각 비트를 반전. 0이면 1, 1이면 0|
|<<|Left Shift|x << 2|x = 00000001(2) = 1 <br> x << 2 → 00000100(2) = 4|비트를 왼쪽으로 이동. 하나 이동할 때마다 곱하기 2|
|>>|Right Shift|x >> 2|x = 00000100(2) = 4 <br> x >> 2 → 00000001(2) = 1|비트를 오른쪽으로 이동. 하나 이동할 때마다 나누기 2|


## 비트를 이용한 부분 집합
- 원소가 n개인 집합
  - 부분 집합의 총 개수 : `1 << n` (= 1을 n번 왼쪽으로 shift 시킴)
  - 표
    |십진수|이진수|{A, B, C, D}|
    |:--:|:--:|:--:|
    |0|0000|{}|
    |1|0001|{A}|
    |2|0010|{B}|
    |3|0011|{A, B}|
    |4|0100|{C}|
    |5|0101|{A, C}|
    |6|0110|{B, C}|
    |7|0111|{A, B, C}|
    |8|1000|{D}|
    |9|1001|{A, D}|
    |10|1010|{B, D}|
    |11|1011|{A, B, D}|
    |12|1100|{C, D}|
    |13|1101|{A, C, D}|
    |14|1110|{B, C, D}|
    |15|1111|{A, B, C, D}|

## 집합에 비트 연산 활용

- 집합에 i번째 원소가 있는지 확인 : `AND연산`과 `LeftShift연산` 활용!
  - (비트로 표현된 집합) & (1 << i) 결과가 0이 아니면 해당원소가 존재
  - 예시 : 2번째 원소가 있는지 확인
    - 0101 & (1 << `2`) = 0101 & 0100 = 0100

- 집합에 i번째 원소를 추가 : `OR연산`과 `LeftShift연산` 활용!
  - (비트로 표현된 집합) | (1 << i) 
  - 예시 : 1번째 원소를 추가
    - 0101 | (1 << `1`) = 0101 | 0010 = 0111

- 집합에 i번째 원소를 삭제 : `AND연산`, `NOT연산`과 `LeftShift연산` 활용!
  - (비트로 표현된 집합) & ~(1 << i)
  - 예시 : 2번째 원소를 삭제
    - 0101 & ~(1 << `2`) = 0101 & ~(0100) = 0101 & 1011 = 0001

## 집합의 원소 개수

- Integer.bitCount(int i) 메서드 사용
- 자체 구현 메서드 사용
  ```java
  int countBits(int n) {
    int ret = 0;
    while(n != 0) {
      // 맨 오른쪽 bit가 1인지 확인
      if ((n & 1) != 0) ++ret;
      // 맨 오른쪽 bit를 오른쪽으로 하나 shift해서 없앰!
      n = n >> 1;
    }
    return ret;
  }
  ```