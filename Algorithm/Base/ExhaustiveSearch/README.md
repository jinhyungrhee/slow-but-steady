# 완전 탐색

- 모든 경우의 수를 시도해보는 방법
  - Exhaustive search, Brute force
- 상대적으로 구현이 간단하고, 해가 존재한다면 시간이 오래걸려도 항상 해를 찾게 됨
- 경우의 수에 따라 실행 시간이 비례하기 때문에, 입력 값의 범위가 작은 경우에 유용함

- 완전 탐색 알고리즘 : 순차 탐색(Sequential search)
  ```java
  int sequentialSearch(int[] arr, int n, int x)
  {
    for (int i = 0; i < n; ++i) {
      if (arr[i] == x)
        return i;
    }
    return -1;
  }
  ```
  - 시간 복잡도 : O(n)
  - 정렬이 되어있다면 '이진 탐색(Binary search)'을 하는 것이 더 유리!

## 경우의 수

- 순열(Permutation)
  - "순서를 가지고 나열하는 것"
  - 선택 순서가 결과에 영향을 미치는 경우

- 조합(Combination)
  - 선택 순서가 결과에 영향을 주지 않는 경우

- 예제
  - `{1, 2, 3, 4}` 숫자가 주어진 경우
  - **① 만들 수 있는 가장 큰 두 자리 수를 구하여라.**
    - 이 경우 순서에 따라 결과가 달라짐! : 14와 41은 다름
    - '순열'로 경우의 수를 나열해야 함!
  - **② 두 수를 더했을 때 가장 큰 합을 구하여라.**
    - 이 경우 순서에 따라 결과가 달라지지 않음! : 1 + 4와 4 + 1은 동일 (덧셈은 교환법칙 성립)
    - '조합'으로 경우의 수를 나열해야 함!