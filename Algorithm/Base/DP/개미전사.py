# |1|3|1|5|

# 왼쪽부터 차례대로 식량창고를 털지 안 털지 결정하는 경우와 특정한 i번째 식량창고에 대해서 털지 안 털지의 여부를 결정할 때 딱 두 가지만 확인
# a. (i-1)번째 식량창고를 털기로 결정한 경우, 현재의 식량창고를 털 수 없음 => "array[i]를 더할 수 없음"
# b. (i-2)번째 식량창고를 털기로 결정한 경우, 현재의 식량창고를 털 수 있음 => "array[i]를 더할 수 있음"
# => a와 b 중 더 많은 식량을 털 수 있는 경우를 선택! 

# 점화식 : Ai = max(Ai-1, Ai-2 + ki) 
# (ki : i번째 식량창고에 있는 식량의 양)
# ** i번째 식량창고에 대한 최적의 해를 구할 때, 왼쪽부터 (i-3)번째 이하의 식량 창고에 대한 최적의 해에 대해선 고려할 필요 X ***
# => d[i] 값을 구할 때는 d[i-1]과 d[i-2]만 고려하면 됨!

n = int(input())

array = list(map(int, input().split()))

d = [0] * 100

d[0] = array[0]

d[1] = max(array[0], array[1]) # i=1일 때의 최적의 해

for i in range(2, n):
  d[i] = max(d[i - 1], d[i - 2] + array[i])

# dp 테이블(d)에는 지금까지 얻은 최대 식량의 수가 저장됨
print(d[n-1])